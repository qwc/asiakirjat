/**
 * htmldiff.js - HTML-aware diff library
 * Produces <ins> and <del> tags for additions and deletions
 * MIT License
 */
(function(global) {
    "use strict";

    // Token types
    var TAG = 1, TEXT = 2, WHITESPACE = 3;

    // Block-level elements (object lookup for O(1))
    var blockTags = {};
    ['div', 'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
     'ul', 'ol', 'li', 'table', 'tr', 'td', 'th',
     'thead', 'tbody', 'tfoot', 'pre', 'blockquote', 'hr', 'br',
     'section', 'article', 'aside', 'nav', 'main',
     'header', 'footer', 'figure', 'figcaption',
     'details', 'summary', 'dl', 'dt', 'dd',
     'form', 'fieldset', 'address', 'hgroup'].forEach(function(t) {
        blockTags[t] = true;
    });

    // Tokenize HTML into tags and text
    function tokenize(html) {
        var tokens = [];
        var re = /(<[^>]+>)|(\s+)|([^<\s]+)/g;
        var match;
        while ((match = re.exec(html)) !== null) {
            if (match[1]) {
                tokens.push({ type: TAG, value: match[1] });
            } else if (match[2]) {
                tokens.push({ type: WHITESPACE, value: match[2] });
            } else if (match[3]) {
                tokens.push({ type: TEXT, value: match[3] });
            }
        }
        return tokens;
    }

    // Check if token is an opening tag
    function isOpenTag(token) {
        return token.type === TAG && token.value.charAt(1) !== '/';
    }

    // Check if token is a closing tag
    function isCloseTag(token) {
        return token.type === TAG && token.value.charAt(1) === '/';
    }

    // Check if token is a self-closing tag (e.g. <br/>, <img .../>)
    function isSelfClosing(token) {
        return token.type === TAG && /\/>$/.test(token.value);
    }

    // Get tag name
    function getTagName(token) {
        var match = token.value.match(/<\/?([a-zA-Z0-9]+)/);
        return match ? match[1].toLowerCase() : '';
    }

    // Check if tokens are equal (for diff purposes)
    // For TAG tokens, compare by tag name and open/close type only (ignore attributes)
    function tokensEqual(a, b) {
        if (a.type !== b.type) return false;
        if (a.type === TAG) {
            var aName = getTagName(a);
            var bName = getTagName(b);
            if (aName !== bName) return false;
            // Must match open/close/self-closing type
            var aClose = isCloseTag(a);
            var bClose = isCloseTag(b);
            if (aClose !== bClose) return false;
            var aSelf = isSelfClosing(a);
            var bSelf = isSelfClosing(b);
            if (aSelf !== bSelf) return false;
            return true;
        }
        return a.value === b.value;
    }

    // Build LCS table
    function buildLCS(oldTokens, newTokens) {
        var m = oldTokens.length;
        var n = newTokens.length;
        var dp = new Array(m + 1);
        for (var i = 0; i <= m; i++) {
            dp[i] = new Array(n + 1).fill(0);
        }
        for (var i = 1; i <= m; i++) {
            for (var j = 1; j <= n; j++) {
                if (tokensEqual(oldTokens[i - 1], newTokens[j - 1])) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp;
    }

    // Backtrack to find operations
    function backtrack(dp, oldTokens, newTokens) {
        var ops = [];
        var i = oldTokens.length;
        var j = newTokens.length;

        while (i > 0 || j > 0) {
            if (i > 0 && j > 0 && tokensEqual(oldTokens[i - 1], newTokens[j - 1])) {
                ops.unshift({ op: 'equal', oldIdx: i - 1, newIdx: j - 1 });
                i--; j--;
            } else if (j > 0 && (i === 0 || dp[i][j - 1] >= dp[i - 1][j])) {
                ops.unshift({ op: 'insert', newIdx: j - 1 });
                j--;
            } else {
                ops.unshift({ op: 'delete', oldIdx: i - 1 });
                i--;
            }
        }
        return ops;
    }

    // Group consecutive operations
    function groupOps(ops) {
        var groups = [];
        var current = null;

        ops.forEach(function(op) {
            if (!current || current.op !== op.op) {
                if (current) groups.push(current);
                current = { op: op.op, items: [op] };
            } else {
                current.items.push(op);
            }
        });
        if (current) groups.push(current);
        return groups;
    }

    // Check if tag is a block-level element
    function isBlockTag(tagName) {
        return blockTags[tagName] === true;
    }

    // Wrap content in ins/del tags intelligently
    // SVG-aware: never split SVG elements with ins/del
    function wrapDiff(tokens, wrapper) {
        if (tokens.length === 0) return '';

        var result = '';
        var inWrap = false;
        var pendingContent = '';
        var svgDepth = 0;
        var svgBuffer = '';

        tokens.forEach(function(token) {
            var tagName = token.type === TAG ? getTagName(token) : '';

            // Track SVG nesting
            if (token.type === TAG && tagName === 'svg') {
                if (isOpenTag(token) && !isSelfClosing(token)) {
                    if (svgDepth === 0) {
                        // Entering SVG: flush pending inline content first
                        if (inWrap && pendingContent) {
                            result += '<' + wrapper + '>' + pendingContent + '</' + wrapper + '>';
                            pendingContent = '';
                            inWrap = false;
                        }
                        svgBuffer = '';
                    }
                    svgDepth++;
                    svgBuffer += token.value;
                    return;
                } else if (isCloseTag(token)) {
                    svgDepth--;
                    svgBuffer += token.value;
                    if (svgDepth <= 0) {
                        // Exiting SVG: emit entire SVG unwrapped
                        result += svgBuffer;
                        svgBuffer = '';
                        svgDepth = 0;
                    }
                    return;
                }
            }

            // Inside SVG: accumulate without wrapping
            if (svgDepth > 0) {
                svgBuffer += token.value;
                return;
            }

            if (token.type === TAG) {
                // Don't wrap block tags themselves, just their content
                if (isBlockTag(tagName)) {
                    if (inWrap && pendingContent) {
                        result += '<' + wrapper + '>' + pendingContent + '</' + wrapper + '>';
                        pendingContent = '';
                        inWrap = false;
                    }
                    result += token.value;
                } else {
                    pendingContent += token.value;
                    inWrap = true;
                }
            } else {
                pendingContent += token.value;
                inWrap = true;
            }
        });

        // Flush any remaining SVG buffer (unclosed SVG)
        if (svgBuffer) {
            result += svgBuffer;
        }

        if (pendingContent) {
            result += '<' + wrapper + '>' + pendingContent + '</' + wrapper + '>';
        }

        return result;
    }

    // Performance guard threshold
    var MAX_TOKENS = 15000;

    // Main diff function
    function htmldiff(oldHtml, newHtml) {
        var oldTokens = tokenize(oldHtml);
        var newTokens = tokenize(newHtml);

        // Performance guard: if either token array is too large, skip diff
        if (oldTokens.length > MAX_TOKENS || newTokens.length > MAX_TOKENS) {
            return '<div class="htmldiff-warning">Document too large for inline diff (' +
                Math.max(oldTokens.length, newTokens.length) +
                ' tokens). Showing current version without diff highlighting.</div>' + newHtml;
        }

        var dp = buildLCS(oldTokens, newTokens);
        var ops = backtrack(dp, oldTokens, newTokens);
        var groups = groupOps(ops);

        var result = '';

        groups.forEach(function(group) {
            if (group.op === 'equal') {
                group.items.forEach(function(item) {
                    result += newTokens[item.newIdx].value;
                });
            } else if (group.op === 'insert') {
                var insertTokens = group.items.map(function(item) {
                    return newTokens[item.newIdx];
                });
                result += wrapDiff(insertTokens, 'ins');
            } else if (group.op === 'delete') {
                var deleteTokens = group.items.map(function(item) {
                    return oldTokens[item.oldIdx];
                });
                result += wrapDiff(deleteTokens, 'del');
            }
        });

        return result;
    }

    // Export
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = htmldiff;
    } else {
        global.htmldiff = htmldiff;
    }

})(typeof window !== 'undefined' ? window : this);
