/**
 * htmldiff.js - HTML-aware diff library
 * Produces <ins> and <del> tags for additions and deletions
 * MIT License
 */
(function(global) {
    "use strict";

    // Token types
    var TAG = 1, TEXT = 2, WHITESPACE = 3;

    // Tokenize HTML into tags and text
    function tokenize(html) {
        var tokens = [];
        var re = /(<[^>]+>)|(\s+)|([^<\s]+)/g;
        var match;
        while ((match = re.exec(html)) !== null) {
            if (match[1]) {
                tokens.push({ type: TAG, value: match[1] });
            } else if (match[2]) {
                tokens.push({ type: WHITESPACE, value: match[2] });
            } else if (match[3]) {
                tokens.push({ type: TEXT, value: match[3] });
            }
        }
        return tokens;
    }

    // Check if token is an opening tag
    function isOpenTag(token) {
        return token.type === TAG && token.value.charAt(1) !== '/';
    }

    // Check if token is a closing tag
    function isCloseTag(token) {
        return token.type === TAG && token.value.charAt(1) === '/';
    }

    // Get tag name
    function getTagName(token) {
        var match = token.value.match(/<\/?([a-zA-Z0-9]+)/);
        return match ? match[1].toLowerCase() : '';
    }

    // Check if tokens are equal (for diff purposes)
    function tokensEqual(a, b) {
        if (a.type !== b.type) return false;
        if (a.type === TAG) {
            return a.value.toLowerCase() === b.value.toLowerCase();
        }
        return a.value === b.value;
    }

    // Build LCS table
    function buildLCS(oldTokens, newTokens) {
        var m = oldTokens.length;
        var n = newTokens.length;
        var dp = new Array(m + 1);
        for (var i = 0; i <= m; i++) {
            dp[i] = new Array(n + 1).fill(0);
        }
        for (var i = 1; i <= m; i++) {
            for (var j = 1; j <= n; j++) {
                if (tokensEqual(oldTokens[i - 1], newTokens[j - 1])) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp;
    }

    // Backtrack to find operations
    function backtrack(dp, oldTokens, newTokens) {
        var ops = [];
        var i = oldTokens.length;
        var j = newTokens.length;

        while (i > 0 || j > 0) {
            if (i > 0 && j > 0 && tokensEqual(oldTokens[i - 1], newTokens[j - 1])) {
                ops.unshift({ op: 'equal', oldIdx: i - 1, newIdx: j - 1 });
                i--; j--;
            } else if (j > 0 && (i === 0 || dp[i][j - 1] >= dp[i - 1][j])) {
                ops.unshift({ op: 'insert', newIdx: j - 1 });
                j--;
            } else {
                ops.unshift({ op: 'delete', oldIdx: i - 1 });
                i--;
            }
        }
        return ops;
    }

    // Group consecutive operations
    function groupOps(ops) {
        var groups = [];
        var current = null;

        ops.forEach(function(op) {
            if (!current || current.op !== op.op) {
                if (current) groups.push(current);
                current = { op: op.op, items: [op] };
            } else {
                current.items.push(op);
            }
        });
        if (current) groups.push(current);
        return groups;
    }

    // Check if tag is a block-level element
    function isBlockTag(tagName) {
        var blockTags = ['div', 'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
                         'ul', 'ol', 'li', 'table', 'tr', 'td', 'th',
                         'thead', 'tbody', 'pre', 'blockquote', 'hr', 'br'];
        return blockTags.indexOf(tagName) !== -1;
    }

    // Wrap content in ins/del tags intelligently
    function wrapDiff(tokens, wrapper) {
        if (tokens.length === 0) return '';

        var result = '';
        var inWrap = false;
        var pendingContent = '';

        tokens.forEach(function(token) {
            if (token.type === TAG) {
                var tagName = getTagName(token);
                // Don't wrap block tags themselves, just their content
                if (isBlockTag(tagName)) {
                    if (inWrap && pendingContent) {
                        result += '<' + wrapper + '>' + pendingContent + '</' + wrapper + '>';
                        pendingContent = '';
                        inWrap = false;
                    }
                    result += token.value;
                } else {
                    pendingContent += token.value;
                    inWrap = true;
                }
            } else {
                pendingContent += token.value;
                inWrap = true;
            }
        });

        if (pendingContent) {
            result += '<' + wrapper + '>' + pendingContent + '</' + wrapper + '>';
        }

        return result;
    }

    // Main diff function
    function htmldiff(oldHtml, newHtml) {
        var oldTokens = tokenize(oldHtml);
        var newTokens = tokenize(newHtml);

        var dp = buildLCS(oldTokens, newTokens);
        var ops = backtrack(dp, oldTokens, newTokens);
        var groups = groupOps(ops);

        var result = '';

        groups.forEach(function(group) {
            if (group.op === 'equal') {
                group.items.forEach(function(item) {
                    result += newTokens[item.newIdx].value;
                });
            } else if (group.op === 'insert') {
                var insertTokens = group.items.map(function(item) {
                    return newTokens[item.newIdx];
                });
                result += wrapDiff(insertTokens, 'ins');
            } else if (group.op === 'delete') {
                var deleteTokens = group.items.map(function(item) {
                    return oldTokens[item.oldIdx];
                });
                result += wrapDiff(deleteTokens, 'del');
            }
        });

        return result;
    }

    // Export
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = htmldiff;
    } else {
        global.htmldiff = htmldiff;
    }

})(typeof window !== 'undefined' ? window : this);
