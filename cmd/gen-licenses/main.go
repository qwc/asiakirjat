// gen-licenses reads vendor/modules.txt and collects license texts from
// vendored dependencies, writing them to internal/licenses/licenses_gen.go.
package main

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

var licenseFileNames = []string{
	"LICENSE",
	"LICENSE.md",
	"LICENSE.txt",
	"LICENCE",
	"LICENCE.md",
	"LICENCE.txt",
	"COPYING",
	"COPYING.md",
	"COPYING.txt",
}

type dep struct {
	module      string
	version     string
	licenseType string
	licenseText string
}

func main() {
	modules, err := os.Open("vendor/modules.txt")
	if err != nil {
		fmt.Fprintf(os.Stderr, "open vendor/modules.txt: %v\n", err)
		os.Exit(1)
	}
	defer modules.Close()

	var deps []dep
	scanner := bufio.NewScanner(modules)
	for scanner.Scan() {
		line := scanner.Text()
		if !strings.HasPrefix(line, "# ") {
			continue
		}
		// Format: "# module/path version"
		parts := strings.Fields(line[2:])
		if len(parts) < 2 {
			continue
		}
		mod := parts[0]
		ver := parts[1]

		licText := findLicense(mod)
		licType := detectLicenseType(licText)
		deps = append(deps, dep{module: mod, version: ver, licenseType: licType, licenseText: licText})
	}
	if err := scanner.Err(); err != nil {
		fmt.Fprintf(os.Stderr, "reading modules.txt: %v\n", err)
		os.Exit(1)
	}

	out, err := os.Create("internal/licenses/licenses_gen.go")
	if err != nil {
		fmt.Fprintf(os.Stderr, "create output: %v\n", err)
		os.Exit(1)
	}
	defer out.Close()

	fmt.Fprintln(out, "// Code generated by cmd/gen-licenses; DO NOT EDIT.")
	fmt.Fprintln(out)
	fmt.Fprintln(out, "package licenses")
	fmt.Fprintln(out)
	fmt.Fprintln(out, "// Deps contains license information for all vendored dependencies.")
	fmt.Fprintln(out, "var Deps = []Dependency{")
	for _, d := range deps {
		fmt.Fprintf(out, "\t{Module: %q, Version: %q, LicenseType: %q, LicenseText: %s},\n",
			d.module, d.version, d.licenseType, goRawString(d.licenseText))
	}
	fmt.Fprintln(out, "}")

	fmt.Printf("Generated licenses for %d dependencies\n", len(deps))
}

// findLicense searches for a license file in the vendor directory for the
// given module path, walking up parent directories for nested modules.
func findLicense(mod string) string {
	path := mod
	for path != "" {
		for _, name := range licenseFileNames {
			fp := filepath.Join("vendor", path, name)
			data, err := os.ReadFile(fp)
			if err == nil {
				return string(data)
			}
		}
		idx := strings.LastIndex(path, "/")
		if idx < 0 {
			break
		}
		path = path[:idx]
	}
	return ""
}

// detectLicenseType returns a short SPDX-like identifier based on
// keywords found in the license text.
func detectLicenseType(text string) string {
	if text == "" {
		return "Unknown"
	}
	t := strings.ToLower(text)

	// Check specific licenses before broad matches
	if strings.Contains(t, "mozilla public license") {
		if strings.Contains(t, "version 2") {
			return "MPL-2.0"
		}
		return "MPL"
	}
	if strings.Contains(t, "apache license") {
		if strings.Contains(t, "version 2") {
			return "Apache-2.0"
		}
		return "Apache"
	}
	if strings.Contains(t, "gnu lesser general public license") {
		return "LGPL"
	}
	if strings.Contains(t, "gnu general public license") {
		return "GPL"
	}
	if strings.Contains(t, "mit license") || strings.Contains(t, "permission is hereby granted, free of charge") {
		return "MIT"
	}
	if strings.Contains(t, "isc license") || (strings.Contains(t, "permission to use, copy, modify") && strings.Contains(t, "isc")) {
		return "ISC"
	}
	if strings.Contains(t, "redistribution and use in source and binary forms") {
		if strings.Contains(t, "neither the name") || strings.Contains(t, "the names of its contributors") {
			return "BSD-3-Clause"
		}
		return "BSD-2-Clause"
	}
	if strings.Contains(t, "unlicense") || strings.Contains(t, "this is free and unencumbered software") {
		return "Unlicense"
	}
	if strings.Contains(t, "public domain") || strings.Contains(t, "cc0") {
		return "Public Domain"
	}
	return "Unknown"
}

// goRawString returns a Go raw string literal for s, falling back to a
// quoted string if s contains backticks.
func goRawString(s string) string {
	if s == "" {
		return `""`
	}
	if !strings.Contains(s, "`") {
		return "`" + s + "`"
	}
	return fmt.Sprintf("%q", s)
}
