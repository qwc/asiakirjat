// gen-licenses reads vendor/modules.txt and collects license texts from
// vendored dependencies, writing them to internal/licenses/licenses_gen.go.
package main

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

var licenseFileNames = []string{
	"LICENSE",
	"LICENSE.md",
	"LICENSE.txt",
	"LICENCE",
	"LICENCE.md",
	"LICENCE.txt",
	"COPYING",
	"COPYING.md",
	"COPYING.txt",
}

type dep struct {
	module  string
	version string
	license string
}

func main() {
	modules, err := os.Open("vendor/modules.txt")
	if err != nil {
		fmt.Fprintf(os.Stderr, "open vendor/modules.txt: %v\n", err)
		os.Exit(1)
	}
	defer modules.Close()

	var deps []dep
	scanner := bufio.NewScanner(modules)
	for scanner.Scan() {
		line := scanner.Text()
		if !strings.HasPrefix(line, "# ") {
			continue
		}
		// Format: "# module/path version"
		parts := strings.Fields(line[2:])
		if len(parts) < 2 {
			continue
		}
		mod := parts[0]
		ver := parts[1]

		licText := findLicense(mod)
		deps = append(deps, dep{module: mod, version: ver, license: licText})
	}
	if err := scanner.Err(); err != nil {
		fmt.Fprintf(os.Stderr, "reading modules.txt: %v\n", err)
		os.Exit(1)
	}

	out, err := os.Create("internal/licenses/licenses_gen.go")
	if err != nil {
		fmt.Fprintf(os.Stderr, "create output: %v\n", err)
		os.Exit(1)
	}
	defer out.Close()

	fmt.Fprintln(out, "// Code generated by cmd/gen-licenses; DO NOT EDIT.")
	fmt.Fprintln(out)
	fmt.Fprintln(out, "package licenses")
	fmt.Fprintln(out)
	fmt.Fprintln(out, "// Deps contains license information for all vendored dependencies.")
	fmt.Fprintln(out, "var Deps = []Dependency{")
	for _, d := range deps {
		fmt.Fprintf(out, "\t{Module: %q, Version: %q, LicenseText: %s},\n",
			d.module, d.version, goRawString(d.license))
	}
	fmt.Fprintln(out, "}")

	fmt.Printf("Generated licenses for %d dependencies\n", len(deps))
}

// findLicense searches for a license file in the vendor directory for the
// given module path, walking up parent directories for nested modules.
func findLicense(mod string) string {
	// Try the module path directly, then walk up parent directories
	path := mod
	for path != "" {
		for _, name := range licenseFileNames {
			fp := filepath.Join("vendor", path, name)
			data, err := os.ReadFile(fp)
			if err == nil {
				return string(data)
			}
		}
		// Walk up: "github.com/foo/bar" -> "github.com/foo"
		idx := strings.LastIndex(path, "/")
		if idx < 0 {
			break
		}
		path = path[:idx]
	}
	return ""
}

// goRawString returns a Go raw string literal for s, falling back to a
// quoted string if s contains backticks.
func goRawString(s string) string {
	if s == "" {
		return `""`
	}
	if !strings.Contains(s, "`") {
		return "`" + s + "`"
	}
	// Use double-quote string with escaping
	return fmt.Sprintf("%q", s)
}
